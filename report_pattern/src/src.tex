\section{Описание}
Для решения задачи был использован алгоритм, основанный на динамическом программировании. 
Алгоритм находит минимальный путь стоимости в матрице, где разрешены переходы только 
вниз и по диагонали в соседние ячейки.

\section{Исходный код}
{\bfseries Основная идея:}

Алгоритм использует двумерный массив для хранения минимальной стоимости достижения 
каждой ячейки матрицы. Для каждой ячейки $(i, j)$ вычисляется минимальная стоимость 
пути из одной из трех возможных предыдущих ячеек: $(i-1, j-1)$, $(i-1, j)$ или $(i-1, j+1)$.

{\bfseries Структуры данных:}

\begin{itemize}
    \item \textbf{struct p\_node} - структура для хранения информации о пути:
    \begin{itemize}
        \item \texttt{\_from} - указатель на предыдущую вершину
        \item \texttt{cost} - минимальная стоимость достижения данной ячейки
        \item \texttt{pos} - позиция в строке
    \end{itemize}
    \item \textbf{matrix} - исходная матрица стоимостей
    \item \textbf{path} - матрица структур p\_node для восстановления пути
\end{itemize}

\subsection{Этапы алгоритма}
\begin{enumerate}
    \item \textbf{Инициализация} (\texttt{path\_init}): 
    Устанавливаются начальные стоимости для первой строки матрицы.
    
    \item \textbf{Прямой проход} (\texttt{forward}): 
    Для каждой ячейки обновляются стоимости трех соседних ячеек в следующей строке.
    
    \item \textbf{Восстановление пути} (\texttt{backtrack}): 
    Находится ячейка с минимальной стоимостью в последней строке и по ссылкам восстанавливается 
    оптимальный путь до первой строки.
\end{enumerate}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>
#include <limits.h>
#include <random>
#include <stack>
using namespace std;

struct p_node
{
    p_node* _from = nullptr;
    long long cost = LLONG_MAX;
    int pos = -1;
};


std::ostream& operator<<(std::ostream& os, const p_node &p) {
    os << p.cost;
    return os;
}

std::ostream& operator<<(std::ostream& os, const pair<long long, long long> &p) {
    os << "(" << p.first << "," << p.second<< ")";
    return os;
}

template<typename T>
void matrix_print(vector<vector<T>> &matrix){
    for (size_t i = 0; i < matrix.size(); i++)
    {
        for (size_t j = 0; j < matrix[0].size(); j++)
        {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}


void path_init(vector<vector<long long>> &matrix, vector<vector<p_node>> &path){
    for (int j = 0; j < matrix[0].size(); j++)
    {
        p_node first_row_node = {nullptr, matrix[0][j], j};
        path[0][j] = first_row_node;
    }
    
    for (size_t i = 1; i < matrix.size(); i++)
    {
        for (int j = 0; j < matrix[0].size(); j++)
        {
            p_node empty_node = {nullptr, LLONG_MAX, j};
            path[i][j] = empty_node;
        }
    }
}

void path_update(p_node &from_node, p_node &to_node, long long plus){
    long long new_cost = from_node.cost + plus;
    if (new_cost < to_node.cost){
        to_node.cost = new_cost;
        to_node._from = &from_node;
    }
}

void forward(vector<vector<long long>> &matrix, vector<vector<p_node>> &path){
    int n = matrix.size();
    int m = matrix[0].size();
    for (size_t i = 0; i < n - 1; i++)
    {
        for (size_t j = 0; j < m; j++)
        {
            if (j == 0){
                path_update(path[i][0], path[i+1][0], matrix[i+1][0]);
                path_update(path[i][0], path[i+1][1], matrix[i+1][1]);
            } else if (j == (m - 1)){
                path_update(path[i][m - 1], path[i+1][m - 2], matrix[i+1][m - 2]);
                path_update(path[i][m - 1], path[i+1][m - 1], matrix[i+1][m - 1]);
            } else {
                path_update(path[i][j], path[i+1][j - 1], matrix[i+1][j - 1]);
                path_update(path[i][j], path[i+1][j], matrix[i+1][j]);
                path_update(path[i][j], path[i+1][j + 1], matrix[i+1][j + 1]);
            }
        }
    }
}

stack<pair<long long, long long>> backtrack(vector<vector<long long>> &matrix, vector<vector<p_node>> &path){

    p_node min_cost_node;

    for (size_t j = 0; j < path[0].size(); j++)
    {
        p_node check = path[path.size() - 1][j];
        if (check.cost < min_cost_node.cost){
            min_cost_node = check;
        }
    }

    cout << min_cost_node.cost << endl;
   
    p_node* current = &min_cost_node;
    int row = path.size();
    stack<pair<long long, long long>> result;

    while(row != 0){
        pair<long long, long long> point;
        point.first = row;
        point.second = current->pos + 1;
        result.push(point);
        row -= 1;
        current = current->_from;
    }

    return result;
}


int main(){
    int n, m;
    cin >> n >> m;
    vector<vector<long long>> matrix(n, vector<long long>(m, 0));    
    vector<vector<p_node>> path(n, vector<p_node>(m));
    stack<pair<long long, long long>> result;
    for (size_t i = 0; i < n; i++)
    {
        for (size_t j = 0; j < m; j++)
        {
            long long cost;
            cin >> cost;
            matrix[i][j] = cost;
        }
    }

    path_init(matrix, path);
    forward(matrix, path);
    result = backtrack(matrix, path);
    
    while (!result.empty()) {
        cout << result.top() << " ";
        result.pop();
    }
    cout << endl;
}


	
\end{lstlisting}

\section{Консоль}
Пример компиляции и демонстрация работы программы:
\begin{alltt}
yugo@yugo-pc:~/Desktop/Labs/DALabs/report\_pattern$ g++ ../lab7/main.cpp -o main
yugo@yugo-pc:~/Desktop/Labs/DALabs/report\_pattern$ ./main 
3 3
1 2 3
4 5 6
7 8 9
12
(1,1) (2,1) (3,1) 
\end{alltt}

